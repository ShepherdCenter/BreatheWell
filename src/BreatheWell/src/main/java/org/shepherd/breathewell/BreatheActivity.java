package org.shepherd.breathewell;

import com.google.android.glass.timeline.LiveCard;
import com.google.android.glass.touchpad.Gesture;
import com.google.android.glass.touchpad.GestureDetector;
import com.google.android.glass.widget.CardBuilder;
import com.google.android.glass.widget.CardScrollView;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.AssetFileDescriptor;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.BitmapDrawable;
import android.media.MediaPlayer;
import android.net.Uri;
import android.os.Bundle;
import android.preference.PreferenceManager;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;
import android.view.WindowManager;
import android.widget.FrameLayout;
import android.widget.TextView;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;

public class BreatheActivity extends Activity {

    /**
     * {@link CardScrollView} to use as the main content view.
     */
    private static final String LOG_TAG = BreatheActivity.class.getName();
    //private CardScrollView mCardScroller;

    /**
     * "Hello World!" {@link View} generated by {@link #buildView()}.
     */
    private View mView;
    private MediaPlayer mediaPlayer;
    private MediaPlayer voicePlayer;
    //private Slider mSlider;
   // private Slider.Determinate mDeterminate;
    float inhale = 4.0F;
    float exhale = 6.0F;
    int EXTRA_ANIM = 0;//1000;
    //ObjectAnimator animatorInhale = null;
    //ObjectAnimator animatorExhale = null;
    boolean beating = false;
    boolean isInhale = true;
    Timer timer;
    TimerTask timerTask;
    int inhale_counter = 0;
    int exhale_counter = 0;
    int counter = 0;
    int currentcycle = 0;
    int breathecycles = 16;
    boolean useMusic = true;
    boolean useVoice = true;

    boolean isFemale = true;

    TextView footer = null;
    TextView breatheLabel = null;
    TextView cycleLabel = null;
    private GestureDetector mGestureDetector;
    FrameLayout layout;
    CustomProgress progress;
    boolean bSaidRelax = false;

    @Override
    protected void onCreate(Bundle bundle) {
        super.onCreate(bundle);
        ((App) BreatheActivity.this.getApplication()).trackView("startbreathing");

        SharedPreferences mPrefs = PreferenceManager.getDefaultSharedPreferences(BreatheActivity.this);

        useMusic = mPrefs.getBoolean("play_music", true);
        int voiceoption = mPrefs.getInt("voiceoption", 0);
        if (voiceoption == 0) { // female
            useVoice = true;
            isFemale = true;
        } else if (voiceoption == 1) { // male
            useVoice = true;
            isFemale = false;
        } else { // no voice
            useVoice = false;
        }
        inhale = mPrefs.getFloat("inhale_cycle", 4.0f);
        exhale = mPrefs.getFloat("exhale_cycle", 6.0f);
        String[] cycles = this.getResources().getStringArray(R.array.cycles);
        int cycle = mPrefs.getInt("cycles", 0);
        breathecycles  = Integer.parseInt(cycles[cycle]);

        mView = buildView();

        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);


        if (useMusic) {
            playMusic();
        }
        if (useVoice) {
            voicePlayer = MediaPlayer.create(BreatheActivity.this, R.raw.f1a);
            voicePlayer.setLooping(false);
            voicePlayer.stop();
        }

        mGestureDetector = createGestureDetector(this);

        setContentView(R.layout.breathe);

        progress = (CustomProgress)this.findViewById(R.id.customProgress);
        progress.setVisibility(View.INVISIBLE);
        Resources res = getResources();
        progress.setTargetPercentage(0.0f);
        progress.setIncreasing(false);
        //progress.useRoundedRectangleShape(30.0f);
        progress.setProgressColor(res.getColor(R.color.green_500));
        progress.setProgressBackgroundColor(res.getColor(R.color.breathe_background));
        progress.setShowingPercentage(false);



        breatheLabel = (TextView)this.findViewById(R.id.breatheLabel);
        cycleLabel = (TextView)this.findViewById(R.id.cycleLabel);
        footer = (TextView)this.findViewById(R.id.footer);
        layout = (FrameLayout)this.findViewById(R.id.layout);
        refreshView();
        removeLiveCard();

    }

    private void setProgressSpeed() {
        progress.setIncreaseRate(inhale);
        progress.setDecreaseRate(exhale);
    }

    private void removeLiveCard() {
        Intent intent = new Intent(this, AlarmReceiver.class);
        intent.putExtra("unpublish", true);
        sendBroadcast(intent);
    }

    private void refreshView() {
        setBackground(layout);
        if (beating) {
            footer.setText("");
            if (isInhale) {
                //breatheLabel.setText(String.format("Inhale %.2f seconds", inhale));
                progress.setText(String.format("Inhale %.2f seconds", inhale));
            } else {
                //breatheLabel.setText(String.format("Exhale %.2f seconds", exhale));
                progress.setText(String.format("Exhale %.2f seconds", exhale));
            }
            cycleLabel.setText(String.format("Cycle %d of %d", currentcycle, breathecycles));
        }
        else {
            footer.setText("tap to start");
            breatheLabel.setText("");
            cycleLabel.setText("");
        }
    }
    //private void setupSliderAnimations() {


//        mSlider = Slider.from(layout);
//        mDeterminate = mSlider.startDeterminate((int)inhale, 0);
//
//        animatorInhale = ObjectAnimator.ofFloat(mDeterminate, "position", 0, inhale);
//        animatorExhale = ObjectAnimator.ofFloat(mDeterminate, "position", exhale, 0);
//
//        // Hide the slider when the animation stops.
//        animatorInhale.addListener(new AnimatorListenerAdapter() {
//            @Override
//            public void onAnimationEnd(Animator animation) {
//                //animatorExhale.setDuration(1000*exhale+EXTRA_ANIM);
//                animatorExhale.start();
//            }
//        });
//
//        animatorExhale.addListener(new AnimatorListenerAdapter() {
//            @Override
//            public void onAnimationEnd(Animator animation) {
//                //animatorInhale.setDuration(1000*inhale+EXTRA_ANIM);
//                animatorInhale.start();
//            }
//        });

    //}

    private GestureDetector createGestureDetector(Context context) {
        GestureDetector gestureDetector = new GestureDetector(context);
        //Create a base listener for generic gestures
        gestureDetector.setBaseListener(new GestureDetector.BaseListener() {
            @Override
            public boolean onGesture(Gesture gesture) {
                Log.i(LOG_TAG, gesture.name());
                if ((gesture == Gesture.TAP) || (gesture == Gesture.LONG_PRESS)) {
                    // do something on tap
                    handleTap();
                    return true;
                } else if (gesture == Gesture.TWO_TAP) {
                    // do something on two finger tap
                    return true;
                } else if (gesture == Gesture.SWIPE_RIGHT) {
                    // do something on right (forward) swipe
                    //Toast.makeText(BreatheActivity.this, "Increase", Toast.LENGTH_SHORT).show();
                    if (isInhale) {
                        inhale += 0.5;
                        //inhale_counter--;
                    } else {
                        exhale += 0.5;
                        exhale_counter++;
                    }
                    cycleChanged();
                    setupAnimationTimers();
                    return true;
                } else if (gesture == Gesture.SWIPE_LEFT) {
                    //Toast.makeText(BreatheActivity.this, "Decrease", Toast.LENGTH_SHORT).show();
                    if (isInhale) {
                        if (inhale > 4.00) {
                            inhale -= 0.5;
                            //inhale_counter++;
                            cycleChanged();
                        }
                    } else {
                        if (exhale > 4.00) {
                            exhale -= 0.5;
                            exhale_counter--;
                            cycleChanged();
                        }
                    }
                    setupAnimationTimers();
                    return true;
                }
                return false;
            }
        });

        return gestureDetector;
    }

    private void cycleChanged() {
        SharedPreferences mPrefs = PreferenceManager.getDefaultSharedPreferences(BreatheActivity.this);

        SharedPreferences.Editor edit = mPrefs.edit();
        edit.putFloat("inhale_cycle", inhale);
        edit.putFloat("exhale_cycle", exhale);
        edit.commit();
        refreshView();
    }
    /*
     * Send generic motion events to the gesture detector
     */
    @Override
    public boolean onGenericMotionEvent(MotionEvent event) {
        if (mGestureDetector != null) {
            return mGestureDetector.onMotionEvent(event);
        }
        return false;
    }

    private void handleTap() {
        if (!beating) {
            beating = true;
            startBreathing();
        } else {
           doneBreathing();
        }
    }

    private void doneBreathing() {
        // open menu?
        setResult(RESULT_OK);
        finish();//finishing activity
    }

    private void setupAnimationTimers()
    {

        setProgressSpeed();
        //animatorInhale.setDuration((long)(1000*inhale+EXTRA_ANIM));
        //animatorExhale.setDuration((long)(1000*exhale+EXTRA_ANIM));

        //syncTimersWithBeat();

    }

    private void syncTimersWithBeat() {
        //breathecounter
        if (isInhale) {
            float fProgress = (inhale_counter / inhale);// * 100);

             //progress.setTargetPercentage(fProgress);
            //animatorInhale.setCurrentPlayTime(inhale_counter * 1000);
        } else {
            float fProgress = (exhale_counter / exhale);// * 100);
            //progress.setTargetPercentage(fProgress);
            long counter = ((int)exhale - exhale_counter)*1000;
            Log.i(LOG_TAG, String.format("fProgress:%f breathcounter:%d calculated slider:%d", fProgress, exhale_counter,counter));
            //animatorExhale.setCurrentPlayTime(counter);
        }
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                progress.refresh();
                //setContentView(buildView());
            }
        });



    }

    private void startBreathing() {

        progress.setVisibility(View.VISIBLE);
        setupAnimationTimers();
        startBeat();
        startInhale();
        //animatorInhale.start();
    }



    private void startBeat() {
        Log.i(LOG_TAG, "startBeat");
        timer = new Timer();

        timerTask = new TimerTask() {
            public void run() {
                heartBeat();
            }
        };

        //schedule the timer, after the first 0 the TimerTask will run every 1000ms
        timer.schedule(timerTask, 0, 1000); //

    }

    public void stopTimer() {
        //stop the timer, if it's not already null
        if (timer != null) {
            timer.cancel();
            timer = null;
        }
    }
    private void heartBeat() {
        if (beating) {
            if (isInhale) {
                inhale_counter++;
                counter = inhale_counter;
                this.snapPercent();
                Log.i(LOG_TAG, "heartBeat " + inhale_counter);
                if (inhale_counter >= inhale) {
                    Log.i(LOG_TAG, "start Exhale ");
                    startExhale();
                }
            } else {
                exhale_counter--;
                counter = exhale_counter;
                this.snapPercent();
                Log.i(LOG_TAG, "heartBeat " + exhale_counter);
                if (exhale_counter <= 0) {
                    Log.i(LOG_TAG, "start Inhale ");
                    startInhale();
                }
            }
            //syncTimersWithBeat();
            if (useVoice) {
                //sayCount();
            }
        }
    }


    private void snapPercent() {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                float percent = 0.0f;
                if (isInhale) {
                    percent = inhale_counter / inhale;
                    //progress.setText(String.format("%d", inhale_counter));
                } else {
                    percent = exhale_counter / exhale;
                    //progress.setText(String.format("%d", exhale_counter));
                }

                progress.snapToPercent(percent);
               // progress.refresh();
            }
        });
    }
    private void startInhale() {


        runOnUiThread(new Runnable() {
            @Override
            public void run() {


                progress.setTargetPercentage(1.0f);
                progress.setIncreasing(true);
                progress.snapToPercent(0.0f);
            }
        });

        currentcycle++;
        if (currentcycle > breathecycles) {
            beating = false;
            doneBreathing();
        }  else {
            syncTimersWithBeat();
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    refreshView();
                    //setContentView(buildView());
                }
            });


            isInhale = true;

            inhale_counter = 0;
            sayInhale();
        }
    }


    private void startExhale() {
        bSaidRelax = false;

        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                progress.snapToPercent(1.0f);
                progress.setTargetPercentage(0.0F);
                progress.setIncreasing(false);
                //progress.reverse();
            }
        });

        isInhale = false;
        exhale_counter = (int)exhale;

        sayExhale();
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                refreshView();
                //setContentView(buildView());
            }
        });
        syncTimersWithBeat();

    }


    private int getCounter() {
        if (isInhale) {
            return inhale_counter;
        } else {
            return exhale_counter;
        }
    }


    @Override
    protected void onResume() {
        if (mediaPlayer != null) {
            mediaPlayer.start();
        }
        super.onResume();
    }

    @Override
    protected void onPause() {
        if (mediaPlayer != null) {
            mediaPlayer.stop();
        }
        super.onPause();
    }

    @Override
    protected void onDestroy() {
        stopTimer();
        if (mediaPlayer != null) {
            mediaPlayer.stop();
            mediaPlayer.release();
        }
        if (voicePlayer != null) {
            voicePlayer.stop();
            voicePlayer.release();
        }
        beating = false;

        super.onDestroy();
    }

    private View buildView() {
        if (currentcycle == 0) {
            CardBuilder card = new CardBuilder(this, CardBuilder.Layout.TEXT);
            card.setFootnote("tap to start");
            View v = card.getView();
            //setBackground(v);
            return v;
        } else
        {
            CardBuilder card = new CardBuilder(this, CardBuilder.Layout.TEXT_FIXED);
            card.setText(String.format("Cycle %d", currentcycle));
            View v = card.getView();
            //setBackground(v);
            return v;
        }
    }

    private void sayResource(int resId) {
        if ((useVoice) && (resId > 0)) {
            AssetFileDescriptor afd = BreatheActivity.this.getResources().openRawResourceFd(resId);
            try {
                if (voicePlayer != null) {
                    voicePlayer.reset();
                    voicePlayer.setDataSource(afd.getFileDescriptor(), afd.getStartOffset(), afd.getDeclaredLength());
                    voicePlayer.prepare();
                    voicePlayer.start();
                }
                afd.close();
            } catch (IllegalArgumentException e) {
                Log.e(LOG_TAG, "Unable to play audio queue do to exception: " + e.getMessage(), e);
            } catch (IllegalStateException e) {
                Log.e(LOG_TAG, "Unable to play audio queue do to exception: " + e.getMessage(), e);
            } catch (IOException e) {
                Log.e(LOG_TAG, "Unable to play audio queue do to exception: " + e.getMessage(), e);
            }
        }
    }

    private void setBackground (FrameLayout layout) {//View v) {
        int background = -1;
        SharedPreferences mPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        int photoSelection = mPrefs.getInt("photo", 0);
        String photoPath = null;
        switch (photoSelection) {
            case 0:
                background = R.drawable.bg_beach;
                break;
            case 1:
                background = R.drawable.bg_frozen;
                break;
            case 2:
                background = R.drawable.bg_horse;
                break;
            case 3:
                background = R.drawable.bg_lake;
                break;
            case 4:
                background = R.drawable.bg_mountains;
                break;
            case 5:
                background = R.drawable.bg_puppy;
                break;
            case 6:
                background = R.drawable.bg_trees;
                break;
            case 7:
                background = R.drawable.bg_water;
                break;
            default:
                photoPath = mPrefs.getString("photopath", "");
                break;
        }
        if (background > -1) {
            layout.setBackgroundResource(background);
        }
        else {
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inPreferredConfig = Bitmap.Config.ARGB_8888;
            Bitmap bitmap = BitmapFactory.decodeFile(photoPath, options);
            BitmapDrawable bd = new BitmapDrawable(bitmap);
            layout.setBackground(bd);
        }


    }

    private int getResId(String resourceName) {
        Resources res = BreatheActivity.this.getResources();
        return res.getIdentifier("raw/" + resourceName, null, this.getPackageName());
//        try {
//            Field idField = c.getDeclaredField(resourceName);
//            return idField.getInt(idField);
//
//        }
//        catch (Exception e) {
//            throw new RuntimeException("No resource ID found for " + resourceName, e);
//        }
    }

    private void sayExhale() {
        int count = currentcycle;//this.getCounter()+1;
        String resourceName  = ((this.isFemale) ? "f": "m")+ new Integer(count).toString()+"b";//.mp3";
        Log.i(LOG_TAG, resourceName);
        sayResource(getResId(resourceName));
    }

    private void sayInhale() {
        int count = currentcycle;//this.getCounter()+1;
        String resourceName  = ((this.isFemale) ? "f": "m" )+ new Integer(count).toString() +"a";//.mp3";
        //resourceName = "f1a";
        Log.i(LOG_TAG, resourceName);
        sayResource(getResId(resourceName));
    }


    private void playMusic() {
        SharedPreferences mPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        int music = mPrefs.getInt("music", 0);
        switch (music+1) {
            case 1:
                mediaPlayer = MediaPlayer.create(this, R.raw.fan);
                break;
            case 2:
                mediaPlayer = MediaPlayer.create(this, R.raw.mediate);
                break;
            case 3:
                mediaPlayer = MediaPlayer.create(this, R.raw.oceanwave);
                break;
            case 4:
                mediaPlayer = MediaPlayer.create(this, R.raw.rain);
                break;
            case 5:
                mediaPlayer = MediaPlayer.create(this, R.raw.rainforest);
                break;
            case 6:
                mediaPlayer = MediaPlayer.create(this, R.raw.stream);
                break;
            case 7:
                mediaPlayer = MediaPlayer.create(this, R.raw.sunshine);
                break;
            default:
                String musicPath = mPrefs.getString("musicpath", "");
                mediaPlayer = MediaPlayer.create(this, Uri.parse(musicPath));
                break;
        }
        mediaPlayer.setLooping(true);
        mediaPlayer.setVolume(0.1F, 0.1F);
        if (useMusic) {
            mediaPlayer.start();
        }
    }


    public static int randInt(int min, int max) {

        // NOTE: Usually this should be a field rather than a method
        // variable so that it is not re-seeded every call.
        Random rand = new Random();

        // nextInt is normally exclusive of the top value,
        // so add 1 to make it inclusive
        int randomNum = rand.nextInt((max - min) + 1) + min;

        return randomNum;
    }

}
